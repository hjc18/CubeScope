<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CubeScope</title>

    <style>
      /* === Layout & Typography === */
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
          Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        color: #fff;
        background: #111;
      }

      canvas {
        display: block;
      }

      /* === Control Panel === */
      #controls {
        position: absolute;
        top: 15px;
        left: 15px;
        padding: 15px;
        max-width: 380px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 8px;
      }

      h1,
      p,
      label {
        margin: 0 0 10px 0;
      }

      h1 {
        font-size: 1.5em;
      }

      p {
        font-size: 0.9em;
        color: #ccc;
      }

      input,
      button {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        box-sizing: border-box;
        border-radius: 4px;
        border: 1px solid #555;
        background: #333;
        color: #fff;
      }

      input[type="color"] {
        padding: 4px;
        min-height: 35px;
      }

      input[type="range"] {
        width: 100%;
      }

      button {
        cursor: pointer;
        background: #007bff;
        border-color: #007bff;
        font-weight: bold;
      }

      button:hover {
        background: #0056b3;
      }

      #slider-container {
        display: none; /* toggled in JS */
      }

      #tip {
        font-size: 0.8em;
        color: #aaa;
        margin-top: -4px;
      }

      #info-panel {
        display: grid;
        grid-template-columns: 60px 1fr;
        gap: 6px 10px;
        font-size: 0.85em;
        color: #ddd;
        background: rgba(255,255,255,0.05);
        padding: 8px;
        border-radius: 6px;
        margin: 6px 0 12px 0;
      }
      #info-panel strong { color: #bbb; font-weight: 600; }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .slider-row input[type="number"] {
        width: 72px;
        margin-bottom: 0;
        padding: 6px 8px;
        background: #2a2a2a;
      }      
    </style>
  </head>

  <body>
    <!-- ===================== Control Panel ===================== -->
    <div id="controls">
      <h1>CubeScope</h1>
      <p>Upload a text file with N*N*N space-separated numbers to visualise the cube, or generate random data.</p>

      <div id="info-panel">
        <strong>N</strong><span id="info-n">–</span>
        <strong>Min</strong><span id="info-min">–</span>
        <strong>Max</strong><span id="info-max">–</span>
      </div>

      <label for="file-input">Data File:</label>
      <input type="file" id="file-input" />

      <label for="base-color">Base Color (max-value):</label>
      <input type="color" id="base-color" value="#3b82f6" />

      <button id="randomize">Random Data</button>

      <label for="cross-toggle" style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="cross-toggle" style="width:auto; margin:0;" />
        <span>Enable Cross-Section Mode</span>
      </label>
      <p id="tip">
        In cross-section mode:
        <br />• Drag sliders to move planes.
        <br />• Click a region to isolate it.
      </p>

      <div id="slider-container">
        <label for="plane-x" style="color:#ff9aa2">X-Plane Position:</label>
        <div class="slider-row">
          <input type="range" id="plane-x" step="1" min="0" max="1" value="0" />
          <input type="number" id="plane-x-val" step="1" min="0" max="1" value="0" />
        </div>

        <label for="plane-y" style="color:#b5e48c">Y-Plane Position:</label>
        <div class="slider-row">
          <input type="range" id="plane-y" step="1" min="0" max="1" value="0" />
          <input type="number" id="plane-y-val" step="1" min="0" max="1" value="0" />
        </div>

        <label for="plane-z" style="color:#89c2ff">Z-Plane Position:</label>
        <div class="slider-row">
          <input type="range" id="plane-z" step="1" min="0" max="1" value="0" />
          <input type="number" id="plane-z-val" step="1" min="0" max="1" value="0" />
        </div>

        <button id="show-all">Show Full Cube</button>
      </div>

      <button id="reset-view">Reset View</button>
    </div>    

    <!-- ====================== Three.js App ===================== -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';
      import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';
      import { LineMaterial } from 'three/addons/lines/LineMaterial.js';

      // ───────────────────────── State ──────────────────────────
      let scene, camera, renderer, controls, voxelGroup;
      let lastLoadedData = null;
      const baseColor = new THREE.Color(0x3b82f6); // nicer default (indigo/blue)

      // individual line materials per plane (light hues)
      const lineMatX = new LineMaterial({ color: 0xff9aa2, linewidth: 3 }); // light red
      const lineMatY = new LineMaterial({ color: 0xb5e48c, linewidth: 3 }); // light green
      const lineMatZ = new LineMaterial({ color: 0x89c2ff, linewidth: 3 }); // light blue

      // Cross-section state
      let crossSectionEnabled = false;
      let planeX = 0, planeY = 0, planeZ = 0, cubeSize = 0;
      const planeFrames = { x: null, y: null, z: null };
      let selectedOctant = null; // null → show all

      const raycaster = new THREE.Raycaster();
      const mouseNDC = new THREE.Vector2();

      const DEFAULT_N = 8; // side length for random initialisation

      // Info panel values
      let infoN = document.getElementById('info-n');
      let infoMin = document.getElementById('info-min');
      let infoMax = document.getElementById('info-max');      

      // ────────────────────── Initialisation ─────────────────────
      function init() {
        // Scene & camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        // Set camera so that +Z is screen up; +X leans left-down, +Y down-right (approx.)
        camera.up.set(0, 0, 1);
        camera.position.set(10, 10, 10);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        
        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 30, 10);
        scene.add(dirLight);

        // Voxel container
        voxelGroup = new THREE.Group();
        scene.add(voxelGroup);

        // Orbit controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // UI events
        window.addEventListener("resize", onWindowResize);
        document.getElementById("file-input").addEventListener("change", handleFileUpload);
        document.getElementById("reset-view").addEventListener("click", () => resetCamera());
        document.getElementById("base-color").addEventListener("input", (e) => {
          baseColor.set(e.target.value);
          if (lastLoadedData) processVoxelData(lastLoadedData);
        });
        document.getElementById("randomize").addEventListener("click", () => randomize());
        document.getElementById("cross-toggle").addEventListener("change", (e) => toggleCrossSection(e.target.checked));

        // Sliders and numeric inputs (bidirectional)
        [
          ['plane-x', 'plane-x-val'],
          ['plane-y', 'plane-y-val'],
          ['plane-z', 'plane-z-val'],
        ].forEach(([rid, nid]) => {
          const r = document.getElementById(rid);
          const n = document.getElementById(nid);
          r.addEventListener('input', () => { n.value = r.value; handlePlaneMove(); });
          n.addEventListener('input', () => { r.value = n.value; handlePlaneMove(); });
        });

        document.getElementById("show-all").addEventListener("click", () => {
          selectedOctant = null;
          updateVoxelVisibility();
        });

        renderer.domElement.addEventListener("pointerdown", onPointerDown);

        // Initialise with random U(0,1) volume
        randomize(DEFAULT_N);

        animate();
      }

      // ──────────────────────── Random data ─────────────────────
      function randomize(n = cubeSize || DEFAULT_N) {
        const values = new Float32Array(n * n * n);
        for (let i = 0; i < values.length; ++i) values[i] = Math.random();
        lastLoadedData = values; // store array (processVoxelData accepts array)
        processVoxelData(values);
      }

      // ──────────────────────── Handlers ─────────────────────────
      function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
          lastLoadedData = ev.target.result;
          processVoxelData(lastLoadedData);
        };
        reader.readAsText(file);
      }

      function toggleCrossSection(enabled) {
        crossSectionEnabled = enabled;
        document.getElementById("slider-container").style.display = enabled ? "block" : "none";

        if (!enabled) {
          selectedOctant = null;
          updateVoxelVisibility();
          showHidePlaneFrames(false);
        } else {
          updatePlaneFrames();
          showHidePlaneFrames(true);
        }
      }

      function handlePlaneMove() {
        planeX = parseInt(document.getElementById("plane-x").value, 10);
        planeY = parseInt(document.getElementById("plane-y").value, 10);
        planeZ = parseInt(document.getElementById("plane-z").value, 10);
        // keep numeric boxes in valid range
        [
          ['plane-x', 'plane-x-val', planeX],
          ['plane-y', 'plane-y-val', planeY],
          ['plane-z', 'plane-z-val', planeZ],
        ].forEach(([rid, nid, v]) => {
          const n = document.getElementById(nid);
          const r = document.getElementById(rid);
          const min = parseInt(r.min, 10), max = parseInt(r.max, 10);
          if (v < min) { v = min; }
          if (v > max) { v = max; }
          n.value = v;
          r.value = v;
        });
        updatePlaneFrames();
        updateVoxelVisibility();
      }

      function onPointerDown(event) {
        if (!crossSectionEnabled) return;

        const rect = renderer.domElement.getBoundingClientRect();
        mouseNDC.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouseNDC.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouseNDC, camera);
        const intersects = raycaster.intersectObjects(voxelGroup.children, false);
        if (intersects.length) {
          const g = intersects[0].object.userData.grid;
          selectedOctant = {
            x: g.x >= planeX,
            y: g.y >= planeY,
            z: g.z >= planeZ,
          };
          updateVoxelVisibility();
        }
      }

      // ───────────────────── Core visual logic ───────────────────
      function processVoxelData(raw) {
        // Clean previous
        scene.remove(voxelGroup);
        voxelGroup.clear();
        scene.remove(...Object.values(planeFrames).filter((m) => m));

        voxelGroup = new THREE.Group();
        scene.add(voxelGroup);

        // Accept either a string (file) or a typed array (random)
        const data = Array.isArray(raw) || ArrayBuffer.isView(raw)
          ? Array.from(raw)
          : raw.trim().split(/\s+/).map(Number);
        if (data.some((v) => Number.isNaN(v))) return alert("Non-numeric values found");

        const n = Math.cbrt(data.length);
        if (n % 1 !== 0 || n === 0) return alert(`${data.length} is not a perfect cube`);
        cubeSize = n;

        // Configure sliders 0 … N
        ["plane-x", "plane-y", "plane-z"].forEach((id) => {
          const r = document.getElementById(id);
          const num = document.getElementById(id+"-val");
          r.min = 0; r.max = n; r.value = Math.floor(n / 2);
          num.min = 0; num.max = n; num.value = Math.floor(n / 2);
        });
        planeX = planeY = planeZ = Math.floor(n / 2);

        // Build voxels
        const dMin = Math.min(...data);
        const dMax = Math.max(...data);
        const geom = new THREE.BoxGeometry(1, 1, 1);
        const white = new THREE.Color(0xffffff);

        for (let i = 0; i < data.length; ++i) {
          const value = data[i];
          const t = dMax > dMin ? (value - dMin) / (dMax - dMin) : 1;
          const colour = new THREE.Color().lerpColors(white, baseColor, t);
          const mat = new THREE.MeshLambertMaterial({ color: colour });
          const voxel = new THREE.Mesh(geom, mat);

          const x = i % n;
          const y = Math.floor(i / n) % n;
          const z = Math.floor(i / (n * n));
          voxel.position.set(x - n / 2 + 0.5, y - n / 2 + 0.5, z - n / 2 + 0.5);
          voxel.userData.grid = { x, y, z };
          voxelGroup.add(voxel);
        }

        // update info panel
        updateInfoPanel(n, dMin, dMax);

        createPlaneFrames();
        updatePlaneFrames();
        showHidePlaneFrames(crossSectionEnabled);
        selectedOctant = null;
        updateVoxelVisibility();

        resetCamera();
      }

      function updateInfoPanel(n, minV, maxV) {
        infoN.textContent = String(n);
        infoMin.textContent = `${minV.toFixed(4)}`;
        infoMax.textContent = `${maxV.toFixed(4)}`;
      }

      function updateVoxelVisibility() {
        voxelGroup.children.forEach((v) => {
          if (!crossSectionEnabled || !selectedOctant) {
            v.visible = true;
            return;
          }
          const g = v.userData.grid;
          const okX = selectedOctant.x ? g.x >= planeX : g.x < planeX;
          const okY = selectedOctant.y ? g.y >= planeY : g.y < planeY;
          const okZ = selectedOctant.z ? g.z >= planeZ : g.z < planeZ;
          v.visible = okX && okY && okZ;
        });
      }

      // ───────────────────── Plane helpers ───────────────────────
      function createPlaneFrames() {
        const makeFrame = (mat) => {
          const pg = new THREE.PlaneGeometry(cubeSize * 1.1, cubeSize * 1.1);
          const edges = new THREE.EdgesGeometry(pg);
          const lineGeom = new LineSegmentsGeometry().fromEdgesGeometry(edges);
          return new LineSegments2(lineGeom, mat);
        };

        planeFrames.x = makeFrame(lineMatX);
        planeFrames.x.rotation.y = Math.PI / 2;

        planeFrames.y = makeFrame(lineMatY);
        planeFrames.y.rotation.x = -Math.PI / 2;

        planeFrames.z = makeFrame(lineMatZ);

        scene.add(planeFrames.x, planeFrames.y, planeFrames.z);
      }

      function updatePlaneFrames() {
        if (!planeFrames.x) return;
        const offset = -cubeSize / 2 + 0.5;
        planeFrames.x.position.x = planeX + offset;
        planeFrames.y.position.y = planeY + offset;
        planeFrames.z.position.z = planeZ + offset;
      }

      function showHidePlaneFrames(show) {
        Object.values(planeFrames).forEach((p) => (p.visible = show));
      }

      function resetCamera() {
        const box = new THREE.Box3().setFromObject(voxelGroup);
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());
        controls.reset();
        controls.target.copy(center);
        camera.position.copy(center).add(new THREE.Vector3(size * 0.8, size * 0.8, size * 0.8));
        camera.lookAt(center);
      }

      // ───────────────────── Boilerplate ─────────────────────────
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        lineMatX.resolution.set(window.innerWidth, window.innerHeight);
        lineMatY.resolution.set(window.innerWidth, window.innerHeight);
        lineMatZ.resolution.set(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        lineMatX.resolution.set(window.innerWidth, window.innerHeight);
        lineMatY.resolution.set(window.innerWidth, window.innerHeight);
        lineMatZ.resolution.set(window.innerWidth, window.innerHeight);

        // render main scene
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
